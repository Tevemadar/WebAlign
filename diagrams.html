<!DOCTYPE html>
<!--
Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
Click nbfs://nbhost/SystemFileSystem/Templates/Other/html.html to edit this template
-->
<html>
    <head>
        <title>WebAlign diagram view</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            html {
                height: 100%;
                overflow: hidden;
            }
            body {
                display: flex;
                flex-direction: column;
                height: 100%;
            }
            #title {
                /*margin: 0.5em;*/
                /*background: red;*/
            }
            #config {
                margin-top: 1em;
                margin-bottom: 1em;
/*                margin: auto;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;*/
            }
            #container{
                display: flex;
                overflow: hidden;
            }
            #cnv-div {
                flex: 1 1;
                overflow: hidden;
            }
            #text-div {
                display: flex;
                flex-direction: column;
                width: 400px;
                /*flex: 0 0 400px;*/
                overflow: hidden;
            }
            #legend {
                font-family: 'Inter','Source Sans Pro',sans-serif;
                font-size: 16px;
                /*background: lightcyan;*/
            }
            #loghead {
                font-family: 'Inter','Source Sans Pro',sans-serif;
                font-size: 16px;
                /*background: lightcyan;*/
                margin-top: 0.5em;
                padding-bottom: 0.5em;
            }
            #log {
                margin-top: 0;
                overflow: auto;
                /*background: lightcyan;*/
            }
            #pop {
                position: absolute;
                background: white;
                padding: 10px;
                border: 1px solid black;
                display: none;
            }
        </style>
        <script src="math.js"></script>
        <script>
            let data = false;
            let regs = false;
            let current = false;
            let mode = 0;
            addEventListener("message", msgHandler, false);
            opener.postMessage("ready.");
            function msgHandler(event) {
                const log=document.getElementById("log");
//                const json=JSON.stringify(event.data, null, 4);
//                const json=JSON.stringify(event.data.sections, null, 4);
//                const json=event.data.sections.map(section=>JSON.stringify(section,null,4)).join(",\n");
                const json=event.data.sections.map(section=>`<div id="${section.filename}">${JSON.stringify(section,null,4)}</div>`).join("");

                log.innerHTML = json;
//                const range=document.createRange();
//                range.setStart(log,4);
//                range.setEnd(log,5);
//                getSelection().addRange(range);

                mode = event.data.mode;
                data = event.data.sections.map(section => {
                    const {filename, width, height, snr, ouv, anchored} = section;

                    const o = ouv.slice(0, 3);
                    const u = ouv.slice(3, 6);
                    const v = ouv.slice(6, 9);
                    const corners = [];
                    for (let w of [[0, 0], [0, 1], [1, 1], [1, 0]])
                        corners.push(o.map((c, i) => c + u[i] * w[0] + v[i] * w[1]));
                    const midpoint = o.map((c, i) => c + u[i] / 2 + v[i] / 2);

                    const coordinates = [snr, ...midpoint, ...rot123uvfrom(section.ouv, mode).map(r => deg(r)).slice(0, 3)];
                    /*
                     * 0: snr
                     * 1: x
                     * 2: y
                     * 3: z
                     * 4: r1
                     * 5: r2
                     * 6: r3
                     */

                    return {filename, width, height, snr, ouv, anchored, corners, midpoint, coordinates};
                });

                current = data[event.data.idx];
                const div=document.getElementById(current.filename);
                div.scrollIntoView({behavior:"smooth",block:"center"});

                const range=document.createRange();
                range.selectNode(div);
                const selection=getSelection();
                selection.addRange(range);

                for (let i = 0; i < data.length; i++) {
                    const section = data[i];
                    section.coordinates.push(...section.midpoint.map((c, idx) => i === 0 ? data[1].midpoint[idx] - c : c - data[i - 1].midpoint[idx]));
                    /*
                     * 7: dx
                     * 8: dy
                     * 9: dz
                     */
                }

                const lraxes = [0, 1, 2].map(() => new LinReg);
                for (const section of data)
                    for (let i = 0; i < 3; i++)
                        lraxes[i].add(section.snr, section.midpoint[i]);
                const A = [0, 1, 2].map(i => lraxes[i].get(data[0].snr));
                const B = [0, 1, 2].map(i => lraxes[i].get(data[data.length - 1].snr));
                const length = Math.hypot(...[0, 1, 2].map(i => A[i] - B[i]));
                const BmA = B.map((b, i) => b - A[i]);
                for (const section of data) {
                    const {ouv} = section;
                    const u = ouv.slice(3, 6);
                    const v = ouv.slice(6, 9);
                    const uxv = cross(u, v);
                    const OmA = A.map((a, i) => ouv[i] - a);
                    section.coordinates.push(section.t = dot(OmA, uxv) * length / dot(BmA, uxv));
                    /*
                     * 10: internal 0-100 // todo
                     */
                }
                for (let i = 0; i < data.length; i++) {
                    const section = data[i];
                    section.coordinates.push(i === 0 ? data[1].t - section.t : section.t - data[i - 1].t);
                    /*
                     * 11: internal 0-100 "spacing" // todo
                     */
                }
                const linregs = data[0].coordinates.map(()=>new LinReg);
                for(const section of data)
                    section.coordinates.forEach((v,i)=>linregs[i].add(section.snr,v));
                regs = linregs.map(linreg=>{
                    const first=data[0];
                    const last=data[data.length-1];
                    return [first.snr,linreg.get(first.snr),last.snr,linreg.get(last.snr)];
                });

                redraw();
            }

            const margins = {top: 20, bottom: 30, left: 50, right: 20};
            const arrow = {length: 20, width: 10};
            const grid = 150;
            const labels = [];
            function redraw() {
                const cnv_div = document.getElementById("cnv-div");
                const cnv = document.getElementById("cnv");
                const width = cnv.width = cnv_div.clientWidth - 10;
                const height = cnv.height = cnv_div.clientHeight - 15;
//                const ctx=cnv.getContext("2d");
//                ctx.moveTo(0,0);
//                ctx.lineTo(cnv.width,cnv.height);
//                ctx.stroke();

                const g = document.getElementById("config").selectedIndex;
                if (g > 5) {
                    overview(cnv);
                    return;
                }
                let format = [
                    "<table><tr><td style='text-align:right'>#</td><td>$1</td></tr><tr><td>Pos.</td><td>$2 voxel</td></tr></table>",
                    "<table><tr><td style='text-align:right'>#</td><td>$1</td></tr><tr><td>Step</td><td>$2 voxel</td></tr></table>",
                    "<table><tr><td style='text-align:right'>#</td><td>$1</td></tr><tr><td>Pos.</td><td>$2 voxel</td></tr></table>",
                    "<table><tr><td style='text-align:right'>#</td><td>$1</td></tr><tr><td>Step</td><td>$2 voxel</td></tr></table>",
                    "<table><tr><td style='text-align:right'>#</td><td>$1</td></tr><tr><td>Rot1</td><td>$2&deg;</td></tr></table>",
                    "<table><tr><td style='text-align:right'>#</td><td>$1</td></tr><tr><td>Rot2</td><td>$2&deg;</td></tr></table>"
                ][g];
                const axis1 = data.map(d => d.snr);
                const axis2 = data.map(d => {
                    switch (g) {
                        case 0: // position cor/sag/hor
                            return d.coordinates[[2, 1, 3][mode]];
                        case 1: // spacing
                            return d.coordinates[[8, 7, 9][mode]];
                        case 2: // internal pos
                            return d.coordinates[10];
                        case 3: // internal spacing
                            return d.coordinates[11];
                        case 4: // primary angle
                            return d.coordinates[4];
                        case 5: // secondary angle
                            return d.coordinates[5];
                    }
                });
                const minx = Math.min(...axis1);
                const maxx = Math.max(...axis1);
                const miny = Math.min(...axis2);
                const maxy = Math.max(...axis2);
                const ctx = cnv.getContext("2d");
                ctx.clearRect(0, 0, width, height);

                const xAxis = axis(width - margins.left - margins.right - arrow.length - arrow.width, minx, maxx);
                const yAxis = axis(height - margins.top - margins.bottom - arrow.length - arrow.width, miny, maxy);
                ctx.font = "14px sans-serif";
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.strokeStyle = "black";
                ctx.beginPath();
                for (const tick of yAxis.ticks) {
                    ctx.moveTo(margins.left, height - margins.bottom - tick[1]);
                    ctx.lineTo(width - margins.right, height - margins.bottom - tick[1]);
                    ctx.strokeText(tick[0], margins.left - 10, height - margins.bottom - tick[1]);
                }
                ctx.strokeStyle = "darkgray";
                ctx.stroke();
                ctx.strokeStyle = "black";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                for (const tick of xAxis.ticks)
                    ctx.strokeText(tick[0], margins.left + tick[1], height - margins.bottom + 10);

                ctx.strokeStyle = "black";
                drawArrows(ctx, width, height);

                const reg=[
//                    case 0: // position cor/sag/hor
                        regs[[2, 1, 3][mode]],
//                    case 1: // spacing
                        regs[[8, 7, 9][mode]],
//                    case 2: // internal pos
                        regs[10],
//                    case 3: // internal spacing
                        regs[11],
//                    case 4: // primary angle
                        regs[4],
//                    case 5: // secondary angle
                        regs[5]
                ][g];
                
                ctx.strokeStyle="orange";
                ctx.lineWidth=2;
                ctx.beginPath();
                ctx.moveTo(margins.left + xAxis.trf(reg[0]), height - margins.bottom - yAxis.trf(reg[1]));
                ctx.lineTo(margins.left + xAxis.trf(reg[2]), height - margins.bottom - yAxis.trf(reg[3]));
                ctx.stroke();

//                labels.length  = 0;
//                ctx.strokeStyle="green";
//                ctx.beginPath();
//                ctx.moveTo(margins.left + xAxis.trf(axis1[0]), height - margins.bottom - yAxis.trf(axis2[0]));
//                for (let i = 0; i < axis1.length; i++) {
//                    const x = axis1[i];
//                    const y = axis2[i];
//                    const tx = margins.left + xAxis.trf(x);
//                    const ty = height - margins.bottom - yAxis.trf(y);
//                    ctx.lineTo(tx, ty);
//                    labels.push({tx, ty, label: data[i].filename+"<br>"+format.replace("$1", x).replace("$2", y.toFixed(2))});
//                }
//                ctx.stroke();

                labels.length  = 0;
//                ctx.strokeStyle="green";
//                ctx.beginPath();
//                ctx.moveTo(margins.left + xAxis.trf(axis1[0]), height - margins.bottom - yAxis.trf(axis2[0]));
                for (let i = 0; i < axis1.length; i++) {
                    const x = axis1[i];
                    const y = axis2[i];
                    const tx = margins.left + xAxis.trf(x);
                    const ty = height - margins.bottom - yAxis.trf(y);
                    labels.push({tx, ty, filename:data[i].filename, label: data[i].filename+"<br>"+format.replace("$1", x).replace("$2", y.toFixed(2))});
                    if(i>0) {
                        const p = labels[i-1];
                        //const px = labels[i-1].x;
                        //const py = labels[i-1].y;
                        ctx.strokeStyle = ["blue", "black", "red"][Math.sign(y - axis2[i-1])+1];
                        ctx.beginPath();
                        ctx.moveTo(p.tx, p.ty);
                        ctx.lineTo(tx,ty);
                        ctx.stroke();
                    }
                }
//                ctx.stroke();
                
                ctx.strokeStyle="green";
                ctx.lineWidth=1;
                for(let i=0;i<labels.length;i++){
//                    ctx.fillStyle=data[i].anchored?"blue":"red";
//                    ctx.strokeStyle=data[i]===current?"orange":"green";
                    ctx.fillStyle=data[i]===current?"orange":data[i].anchored?"green":"white";
                    ctx.beginPath();
                    ctx.ellipse(labels[i].tx,labels[i].ty,5,5,0,0,Math.PI*2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            function axis(length, min, max) {
                //debugger;
                if (min === max)
                    return {
                        ticks: [[min, length / 2]],
                        trf: () => length / 2
                    };
                const absmax = Math.max(Math.abs(min), Math.abs(max));
                const absmaxlog = Math.max(Math.floor(Math.log10(absmax)), 0);
                /*if (absmaxlog >= 0)*/ {
                    const absmax10 = 10 ** absmaxlog;
                    const step = length / grid < (max - min) / absmax10 ? absmax10 : absmax10 / 2;
                    const mintick = Math.floor(min / step);
                    const maxtick = Math.ceil(max / step);
                    const trf = data => (data / step - mintick) * length / (maxtick - mintick);
                    const ticks = [];
                    for (let tick = mintick * step; tick <= maxtick * step; tick += step) {
                        ticks.push([tick, trf(tick)]);
                    }
                    return {ticks, trf};
                }
            }
            
            function overview(cnv) {
                const width = cnv.width;
                const xSpace = width - margins.left - margins.right - arrow.length - arrow.width;
                const height = cnv.height;
                const ySpace = height - margins.top - margins.bottom - arrow.length - arrow.width;
                
                const m = document.getElementById("config").selectedIndex - 5;
                const i1 = [1,0,0][m];
                const i2 = [2,1,2][m];
                // side, top, front

                const min = [0,1,2].map(() => Number.MAX_VALUE);
                const max = min.map(v => -v);
                
                for(const section of data)
                    for(const corner of section.corners)
                        for(let i=0; i < 3; i++) {
                            if(min[i] > corner[i])
                                min[i] = corner[i];
                            if(max[i] < corner[i])
                                max[i] = corner[i];
                        }
                const xRange=max[i1]-min[i1];
                const yRange=max[i2]-min[i2];
                
                
                let format = [
                    "<table><tr><td>x</td><td>$1 voxel</td></tr><tr><td>z</td><td>$2 voxel</td></tr></table>",
                    "",
                    ""
                ][m];
                const axis1 = data.map(d => d.snr);
                const axis2 = data.map(d => {
                    switch (g) {
                        case 0: // position cor/sag/hor
                            return d.coordinates[[2, 1, 3][mode]];
                        case 1: // spacing
                            return d.coordinates[[8, 7, 9][mode]];
                        case 2: // internal pos
                            return d.coordinates[10];
                        case 3: // internal spacing
                            return d.coordinates[11];
                        case 4: // primary angle
                            return d.coordinates[4];
                        case 5: // secondary angle
                            return d.coordinates[5];
                    }
                });
                const minx = Math.min(...axis1);
                const maxx = Math.max(...axis1);
                const miny = Math.min(...axis2);
                const maxy = Math.max(...axis2);
                const ctx = cnv.getContext("2d");
                ctx.clearRect(0, 0, width, height);

                const xAxis = axis(width - margins.left - margins.right - arrow.length - arrow.width, minx, maxx);
                const yAxis = axis(height - margins.top - margins.bottom - arrow.length - arrow.width, miny, maxy);
                ctx.font = "14px sans-serif";
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.strokeStyle = "black";
                ctx.beginPath();
                for (const tick of yAxis.ticks) {
                    ctx.moveTo(margins.left, height - margins.bottom - tick[1]);
                    ctx.lineTo(width - margins.right, height - margins.bottom - tick[1]);
                    ctx.strokeText(tick[0], margins.left - 10, height - margins.bottom - tick[1]);
                }
                ctx.strokeStyle = "darkgray";
                ctx.stroke();
                ctx.strokeStyle = "black";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                for (const tick of xAxis.ticks)
                    ctx.strokeText(tick[0], margins.left + tick[1], height - margins.bottom + 10);

                ctx.strokeStyle = "black";
                drawArrows(ctx, width, height);

                const reg=[
//                    case 0: // position cor/sag/hor
                        regs[[2, 1, 3][mode]],
//                    case 1: // spacing
                        regs[[8, 7, 9][mode]],
//                    case 2: // internal pos
                        regs[10],
//                    case 3: // internal spacing
                        regs[11],
//                    case 4: // primary angle
                        regs[4],
//                    case 5: // secondary angle
                        regs[5]
                ][g];
                
                ctx.strokeStyle="orange";
                ctx.lineWidth=2;
                ctx.beginPath();
                ctx.moveTo(margins.left + xAxis.trf(reg[0]), height - margins.bottom - yAxis.trf(reg[1]));
                ctx.lineTo(margins.left + xAxis.trf(reg[2]), height - margins.bottom - yAxis.trf(reg[3]));
                ctx.stroke();

//                labels.length  = 0;
//                ctx.strokeStyle="green";
//                ctx.beginPath();
//                ctx.moveTo(margins.left + xAxis.trf(axis1[0]), height - margins.bottom - yAxis.trf(axis2[0]));
//                for (let i = 0; i < axis1.length; i++) {
//                    const x = axis1[i];
//                    const y = axis2[i];
//                    const tx = margins.left + xAxis.trf(x);
//                    const ty = height - margins.bottom - yAxis.trf(y);
//                    ctx.lineTo(tx, ty);
//                    labels.push({tx, ty, label: data[i].filename+"<br>"+format.replace("$1", x).replace("$2", y.toFixed(2))});
//                }
//                ctx.stroke();

                labels.length  = 0;
//                ctx.strokeStyle="green";
//                ctx.beginPath();
//                ctx.moveTo(margins.left + xAxis.trf(axis1[0]), height - margins.bottom - yAxis.trf(axis2[0]));
                for (let i = 0; i < axis1.length; i++) {
                    const x = axis1[i];
                    const y = axis2[i];
                    const tx = margins.left + xAxis.trf(x);
                    const ty = height - margins.bottom - yAxis.trf(y);
                    labels.push({tx, ty, filename:data[i].filename, label: data[i].filename+"<br>"+format.replace("$1", x).replace("$2", y.toFixed(2))});
                    if(i>0) {
                        const p = labels[i-1];
                        //const px = labels[i-1].x;
                        //const py = labels[i-1].y;
                        ctx.strokeStyle = ["blue", "black", "red"][Math.sign(y - axis2[i-1])+1];
                        ctx.beginPath();
                        ctx.moveTo(p.tx, p.ty);
                        ctx.lineTo(tx,ty);
                        ctx.stroke();
                    }
                }
//                ctx.stroke();
                
                ctx.strokeStyle="green";
                ctx.lineWidth=1;
                for(let i=0;i<labels.length;i++){
//                    ctx.fillStyle=data[i].anchored?"blue":"red";
//                    ctx.strokeStyle=data[i]===current?"orange":"green";
                    ctx.fillStyle=data[i]===current?"orange":data[i].anchored?"green":"white";
                    ctx.beginPath();
                    ctx.ellipse(labels[i].tx,labels[i].ty,5,5,0,0,Math.PI*2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            function drawArrows(ctx, width, height) {
                ctx.save();
                ctx.strokeStyle = "black";
                ctx.fillStyle = "black";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(margins.left, margins.top);
                ctx.lineTo(margins.left - arrow.width / 2, margins.top + arrow.length);
                ctx.lineTo(margins.left + arrow.width / 2, margins.top + arrow.length);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.lineTo(margins.left, margins.top);
                ctx.lineTo(margins.left, height - margins.bottom);
                ctx.lineTo(width - margins.right, height - margins.bottom);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(width - margins.right, height - margins.bottom);
                ctx.lineTo(width - margins.right - arrow.length, height - margins.bottom - arrow.width / 2);
                ctx.lineTo(width - margins.right - arrow.length, height - margins.bottom + arrow.width / 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }


//            function steps(min, max, scale, spacing) {
//                const target_spacing = spacing / scale;
//            }
//
//            function tx(x) {
//                const {minx, scl} = diagram;
//                return ml + (x - minx) * scl;
//            }
//            function ty(y) {
//                const {maxy, scl} = diagram;
//                return mt + (maxy - y) * scl;
//            }
//            function moveTo(x, y) {
//                diagram.ctx.moveTo(tx(x), ty(y));
//            }
//            function lineTo(x, y) {
//                diagram.ctx.lineTo(tx(x), ty(y));
//            }

//            const corners = [[0, 0], [0, 1], [1, 1], [1, 0]];
            function redraw_r() {
                const typ = document.getElementById("view").selectedIndex;
                document.getElementById("adv_group").hidden = document.getElementById("axis2").hidden = typ < 3;
                const cnv = document.getElementById("cnv");
                const ctx = cnv.getContext("2d");
                if (typ < 3) {
                    const min = [Number.MAX_VALUE, Number.MAX_VALUE];
                    const max = min.map(x => -x);
                    const pair = [[1, 0], [0, 2], [1, 2]][typ];
                    for (const section of data)
                        for (const corner of section.corners)
                            for (const idx of [0, 1]) {
                                const coord = corner[pair[idx]];
                                if (coord < min[idx])
                                    min[idx] = coord;
                                if (coord > max[idx])
                                    max[idx] = coord;
                            }
                    setupCanvas(...min, ...max);
                    ctx.strokeStyle = "black";
                    for (const section of data) {
                        if (section !== current) {
                            ctx.beginPath();
//                        ctx.moveTo(section.corners[0][pair[0]] - min[0] + 20, section.corners[0][pair[1]] - min[1] + 20);
                            moveTo(section.corners[0][pair[0]], section.corners[0][pair[1]]);
                            for (const corner of section.corners)
                                lineTo(corner[pair[0]], corner[pair[1]]);
//                            ctx.lineTo(corner[pair[0]] - min[0] + 20, corner[pair[1]] - min[1] + 20);
                            ctx.closePath();
                            ctx.stroke();
                        }
                        section.diagx = section.midpoint[pair[0]];
                        -min[0] + 20;
                        section.diagy = section.midpoint[pair[1]];
                        -min[1] + 20;
                    }
                } else {
                    const axis1 = document.getElementById("axis1").selectedIndex;
                    const axis2 = document.getElementById("axis2").selectedIndex;
                    let minx = Number.MAX_VALUE;
                    let miny = Number.MAX_VALUE;
                    let maxx = -minx;
                    let maxy = -miny;
                    for (const section of data) {
//                        const numbers = [section.snr, ...section.ouv.slice(0, 3), ...rot123uvfrom(section.ouv, 0).map(r => deg(r))];
                        const x = section.diagx = section.coordinates[axis1];
                        const y = section.diagy = section.coordinates[axis2];
                        if (minx > x)
                            minx = x;
                        if (maxx < x)
                            maxx = x;
                        if (miny > y)
                            miny = y;
                        if (maxy < y)
                            maxy = y;
                    }
                    setupCanvas(minx, miny, maxx, maxy);
//                    cnv.width = maxx - minx + 40;
//                    cnv.height = maxy - miny + 40;
//                    for (const section of data) {
//                        section.diagx -= minx - 20;
//                        section.diagy -= miny - 20;
//                    }
                }
                ctx.lineWidth = 2;
                if (typ < 3) {
                    ctx.strokeStyle = "red";
                    ctx.beginPath();
                    moveTo(data[0].diagx, data[0].diagy);
                    for (const section of data)
                        lineTo(section.diagx, section.diagy);
                    ctx.stroke();
                } else {
                    let prev = false;
                    for (const section of data) {
                        const curr = [section.diagx, section.diagy];
                        if (prev) {
                            ctx.beginPath();
                            moveTo(...prev);
                            lineTo(...curr);
                            ctx.strokeStyle = ["blue", "black", "red"][Math.sign(curr[1] - prev[1]) + 1];
                            ctx.stroke();
                        }
                        prev = curr;
                    }
                }
                ctx.lineWidth = 1;
                ctx.strokeStyle = "blue";
                for (const section of data) {
                    if (section === current) {
                        ctx.beginPath();
                        ctx.ellipse(tx(section.diagx), ty(section.diagy), 10, 10, 0, 0, Math.PI * 2);
                        ctx.fillStyle = "orange";
                        ctx.fill();
                    }
                    ctx.beginPath();
                    ctx.ellipse(tx(section.diagx), ty(section.diagy), 5, 5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = section.anchored ? "green" : "red";
                    ctx.fill();
                    ctx.stroke();
                }
                if (typ < 3) {
                    debugger;
                    const pair = [[1, 0], [0, 2], [1, 2]][typ];
                    ctx.strokeStyle = "orange";
                    ctx.lineWidth = 2;
//                    for (const section of data) {
                    ctx.beginPath();
//                        ctx.moveTo(section.corners[0][pair[0]] - min[0] + 20, section.corners[0][pair[1]] - min[1] + 20);
                    moveTo(current.corners[0][pair[0]], current.corners[0][pair[1]]);
                    for (const corner of current.corners)
                        lineTo(corner[pair[0]], corner[pair[1]]);
//                            ctx.lineTo(corner[pair[0]] - min[0] + 20, corner[pair[1]] - min[1] + 20);
                    ctx.closePath();
                    ctx.stroke();
//                        section.diagx = section.midpoint[pair[0]];
//                        -min[0] + 20;
//                        section.diagy = section.midpoint[pair[1]];
//                        -min[1] + 20;
//                    }
                }
            }

            function mout() {
                document.getElementById("pop").style.display = "none";
            }
            function mmove(event) {
                let item = false;
                for (const label of labels)
                    if (Math.hypot(event.offsetX - label.tx, event.offsetY - label.ty) <= 5)
                        item = label;
                const pop = document.getElementById("pop");
                pop.style.display = item ? "block" : "none";
                if (item) {
                    pop.style.left = event.clientX + 15 + "px";
                    pop.style.top = event.clientY - 15 + "px";
                    pop.innerHTML = item.label;

                    const div=document.getElementById(item.filename);
                    div.scrollIntoView({behavior:"smooth",block:"center"});

                    const range=document.createRange();
                    range.selectNode(div);
                    const selection=getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                }
            }
            function dclick(event) {
                let idx = -1;
                for (let i = 0; i < labels.length; i++) {
                    const label = labels[i];
                    if (Math.hypot(event.offsetX - label.tx, event.offsetY - label.ty) <= 5)
                        idx = i;
                }
                if (idx >= 0) {
                    opener.postMessage(idx);
                    opener.focus();
                }
            }

            function rot123uvfrom(ouv, mode) {
                let u = ouv.slice(3, 6);
                let v = ouv.slice(6);
                let ul = normalize(u, 0);
                let vl = normalize(v, 0);
                let n = cross(u, v);
                normalize(n, 0);
                let rot1, rot2, baseu;
                switch (mode) {
                    case 0:
                        rot1 = Math.asin(clamp(n[2]));
                        rot2 = Math.atan2(n[0], n[1]);
                        baseu = [Math.cos(rot2), -Math.sin(rot2), 0];
                        break;
                    case 1:
                        rot1 = -Math.asin(clamp(n[2]));
                        rot2 = -Math.atan2(n[1], n[0]);
                        baseu = [-Math.sin(rot2), -Math.cos(rot2), 0];
                        break;
                    case 2:
                        rot1 = Math.asin(clamp(n[0]));
                        rot2 = -Math.atan2(n[1], n[2]);
                        baseu = [0, -Math.cos(rot2), -Math.sin(rot2)];
                        break;
                }
                let rot3 = Math.acos(clamp(dot(u, baseu))) * Math.sign(dot(cross(u, baseu), n));
                return [rot1, rot2, rot3, ul, vl];
            }
            function set_adv(event) {
                if (event.target.checked) {
                    adv_span.hidden = true;
                    axis1.hidden = false;
                } else {
                    adv_span.hidden = false;
                    axis1.hidden = true;
                    axis1.selectedIndex = 0;
                    redraw();
                }
            }
            function legdot(id, color) {
                const cnv=document.getElementById(id);
                cnv.width=20;
                cnv.height=12;
                const ctx=cnv.getContext("2d");
                ctx.fillStyle=color;
                ctx.strokeStyle="green";
                ctx.lineWidth=1;
                ctx.beginPath();
                ctx.ellipse(10,6,5,5,0,0,Math.PI*2);
                ctx.fill();
                ctx.stroke();
            }
            function legline(id, color) {
                const cnv=document.getElementById(id);
                cnv.width=20;
                cnv.height=12;
                const ctx=cnv.getContext("2d");
                ctx.strokeStyle=color;
                ctx.lineWidth=2;
                ctx.beginPath();
                ctx.moveTo(5,6);
                ctx.lineTo(15,6);
                ctx.stroke();
            }
            function legend() {
                legdot("cnv_cur","orange");
                legdot("cnv_anc","green");
                legdot("cnv_nanc","white");
                legline("cnv_trend","orange");
                legline("cnv_inc","red");
                legline("cnv_dec","blue");
                legline("cnv_cons","black");
            }
        </script>
    </head>
    <body onresize="redraw()" onload="legend()">
        <div id="title">
            <select id="config" onchange="redraw()">
                <option>Position</option>
                <option>Spacing</option>
                <option>Position (series axis)</option>
                <option>Spacing (series axis)</option>
                <option>Primary angle</option>
                <option>Secondary angle</option>
<!--                <option>Side view</option>
                <option>Top view</option>
                <option>Front view</option>-->
            </select>
        </div>
        <div id="container">
            <div id="cnv-div">
                <canvas id="cnv" onmousemove="mmove(event)" ondblclick="dclick(event)" onmouseout="mout()"></canvas>
            </div>
            <div id="text-div">
                <div id="legend">
                    <p style="margin-top: 0;margin-bottom: 0.5em;">Info</p>
                    <table>
                        <tr><td><canvas id="cnv_cur"></canvas></td><td>Current section</td></tr>
                        <tr><td><canvas id="cnv_anc"></canvas></td><td>Section anchored</td></tr>
                        <tr><td><canvas id="cnv_nanc"></canvas></td><td>Section not anchored</td></tr>
                        <tr><td><canvas id="cnv_trend"></canvas></td><td>Trend</td></tr>
                        <tr><td><canvas id="cnv_inc"></canvas></td><td>Value increasing</td></tr>
                        <tr><td><canvas id="cnv_dec"></canvas></td><td>Value decreasing</td></tr>
                        <tr><td><canvas id="cnv_cons"></canvas></td><td>No change</td></tr>
                    </table>
                    <p>Hover the mouse cursor over a section marker to see name, section number, and value.</p>
                    <p>Double-click to activate the section in the WebAlign window.</p>
                </div>
                <div id="loghead">Raw data</div>
                <pre id="log"></pre>
            </div>
        </div>
        <div id="pop"></div>
    </body>
</html>
