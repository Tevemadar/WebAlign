<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>WebAlign v0.1</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            html,body{
                height: 100%;
                margin: 0;
                overflow: hidden;
            }
            body{
                background: purple;
                padding: 0;
            }
            div{
                position: absolute;
            }
            #controls{
                /*background: red;*/
                background: white;
            }
            #hsiz{
                cursor: ew-resize;
            }
            #main{
                background: white;
                overflow: hidden;
            }
            .hsep{
                width: 10px;
                background: grey;
            }
            #navi{
                background: green;
                overflow: hidden;
            }
            #vsiz{
                height: 10px;
                background: grey;
                cursor: ns-resize;
            }
            #filmstrip{
                background: white;
                height: 128px;
                overflow: hidden;
            }
            canvas{
                margin: 0;
                padding: 0;
                border: 0;
            }
            #cover{
                background: darkgray;
                opacity: 0.5;
                position: absolute;
                top:0;
                left:0;
                width: 100%;
                height: 100%;
            }
            #popup,#popcont{
                background: white;
                position: absolute;
                top:0;
                bottom:0;
                left:0;
                right:0;
                margin:auto;
            }
            #popup{
                width: 500px;
                height: 300px;
            }
            #popcont{
                width: max-content;
                height: max-content;
            }
            .stepgroup{
                position:absolute;
                margin:0;
                padding:0;
                /*background: red;*/
                display:flex;
            }
            .stepgroup>button{
                margin:0;
                padding:0;
            }
            .ctrlrow{
                position: static;
                display:flex;
                align-items: center;
                margin-bottom: 5px;
                margin-top: 5px;
            }
            /*input[type=range]{*/
            /*width:100px;*/
            /*}*/
            #help{
                position: absolute;
                right: 0;
                display: none;
                width: 500px;
                background: #F0F0F0;
                padding: 10px;
            }
            kbd {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 0.1em 0.5em;
                margin: 0 0.2em;
                box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2), 0 0 0 2px #fff inset;
                background-color: #f7f7f7;
            }        
        </style>
        <script src="slicer.js"></script>
        <script src="math.js"></script>
        <script src="zipstore.js"></script>
        <!--<script src="dzimage.js"></script>-->
        <script src="segrle.js"></script>
        <script src="dppick.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Tevemadar/NetUnzip/inflater.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Tevemadar/NetUnzip/netunzip.min.js"></script>
        <script>
            let args = JSON.parse(decodeURIComponent(location.search.substring(1)));
            const bucket = args["clb-collab-id"];
            const token = args.token;
            let filename = args.filename;
            async function dpurlget(bucketfile) {
                return fetch(
                        `https://data-proxy.ebrains.eu/api/v1/buckets/${bucketfile}?redirect=false`,
                        {headers: {authorization: `Bearer ${token}`}}).then(response => response.json());
            }
            const oldisv="https://object.cscs.ch/v1/AUTH_08c08f9f119744cbbf77e216988da3eb/";

            let atlas = {xdim: 1, ydim: 1, zdim: 1};
            let series;
            let images = [];
            let fsw = 0;
            let ready = false;
            let gray;
            async function startup() {
                let start = Date.now();
                popup("Loading data");
                window.addEventListener("resize", resize);
                resize();
                const url = await dpurlget(bucket + "/" + filename).then(json => json.url);
                series = await fetch(url + "?" + Date.now()).then(response => response.json());
                if (series.hasOwnProperty("mode"))
                    document.getElementById("mode").selectedIndex = series.mode;
                console.log(Date.now() - start, "Got series");
                /*let*/ atlas = new Promise(resolve => new Worker("getlas.js?" + series.atlas)
                            .onmessage = event => {
                                if (event.data.hasOwnProperty("blob"))
                                    resolve(event.data);
                                else
                                    popup(event.data);
                            });
                new Worker("getgray.js?" + series.atlas).onmessage = event => {
                    gray = new Uint8Array(event.data);
                    document.getElementById("modality").disabled = false;
                };
//                let worker=new Worker("getlas.js?"+args.get("atlas"));

                const wfprefix=".nesysWorkflowFiles/zippedPyramids/";
                for (let section of series.sections) {
                    // {"name":"hbp-00167-641_2001_2561_s001.tif","width":22500,"height":17500,"tilesize":254,"overlap":1,"format":"png"}
                    const fullname = section.filename;
                    let image;
                    if(!fullname.endsWith(".dzip")){
                        const pos = fullname.lastIndexOf(".");
                        const name = fullname.substring(0, pos);


                        image = {
                            ...section, base: (series.bucket?series.bucket:series.oldisv) + "/" + fullname + "/" + name + "_files/", flat: name + ".flat"
                        };
                    } else {
                        // "filename":"10000pxtest/2022-268_InjectionSite_5X_Overview_s026.dzip"
                        const dzip=`${series.bucket}/.nesysWorkflowFiles/zippedPyramids/${fullname}`;
                        const name=fullname.slice(fullname.lastIndexOf("/")+1,-".dzip".length);
                        image = {...section,filename:name,dzip,base:name+"_files/",flat: name + ".flat"};
                    }

                    let w = image.width;
                    let h = image.height;

                    image.fsx = fsw;
                    if (w > h) {
                        image.fsw = 128;
                        image.fsh = h * 128 / w;
                        image.fsy = (128 - image.fsh) / 2;
                    } else {
                        image.fsh = 128;
                        image.fsy = 0;
                        image.fsw = w * 128 / h;
                    }
                    fsw += 30 + image.fsw;

                    let maxlevel = 0;
                    while (w > 1 || h > 1) {
                        w = (w + 1) >> 1;
                        h = (h + 1) >> 1;
                        maxlevel++;
                    }
                    image.maxlevel = maxlevel;
                    images.push(image);
                }
                fsw -= 30;
                console.log(Date.now() - start, "Got DZIs");
                atlas = await atlas;
                atlas.blob = atlas.encoding === 1 ? new Uint8Array(atlas.blob) : new Uint16Array(atlas.blob);
                console.log(Date.now() - start, "Got atlas");
                console.log(atlas);
                document.getElementById("atlas").innerText = atlas.name;

                for (let image of images) {
                    if (image.hasOwnProperty("ouv"))
                        image.anchored = true;
                    image.snr = parseInt(image.filename.match(/_s(\d+)/)[1]);
                }
                propagate();

                //stripidx=Math.min(images.length-1,(images.length>>1)+1);
                if (!series.hasOwnProperty("current"))
                    series.current = images.length >> 1;
                activateslice(series.current);
                strippos = images[stripidx].fsx - (window.innerWidth - images[stripidx].fsw) / 2;
                console.log(images[stripidx]);
                console.log(strippos);

                ready = true;
                resize();
                console.log(images);
                cover();
            }
            let ctrlw = 300;
            let fstrip = 128;
            let width;
            let mainh;
            let mainw;
            function resize() {
                let ctrl = document.getElementById("controls");
                let hsiz = document.getElementById("hsiz");
                let main = document.getElementById("main");
                let hsep = document.getElementById("hsep");
                let navi = document.getElementById("navi");
                let vsiz = document.getElementById("vsiz");
                let fstr = document.getElementById("filmstrip");

                let maincnv = document.getElementById("maincnv");
                let navicnv = document.getElementById("navicnv");
                let filmcnv = document.getElementById("filmcnv");

                if (fstrip > 128)
                    fstrip = 128;
                if (fstrip < 0)
                    fstrip = 0;
                width = filmcnv.width = window.innerWidth;

                mainh = maincnv.height = navicnv.height = window.innerHeight - fstrip - vsiz.offsetHeight;
                ctrl.style.height =
                        hsiz.style.height =
                        main.style.height =
                        hsep.style.height =
                        navi.style.height =
                        vsiz.style.top = mainh + "px";
                nfact = (mainh - 10 - 10) / (atlas.zdim + atlas.zdim + atlas.xdim);
                navw = navicnv.width = nfact * Math.max(atlas.ydim, atlas.xdim);
                ctrl.style.width = hsiz.style.left = ctrlw + "px";
                navi.style.left = (width - navw) + "px";
                navi.style.width = navw + "px";
                hsep.style.left = (width - navw - hsep.offsetWidth) + "px";
                main.style.left = (ctrlw + hsiz.offsetWidth) + "px";
                mainw = maincnv.width = width - ctrlw - navw - hsiz.offsetWidth - hsep.offsetWidth;
                main.style.width = mainw + "px";
                vsiz.style.width = fstr.style.width = width + "px";
                fstr.style.top = (window.innerHeight - fstrip) + "px";
                filmcnv.height = fstrip;
                fstr.style.height = fstrip + "px";
                drawX("maincnv");
                drawX("navicnv");
                drawX("filmcnv");
                drawstrip();
                imagenavi();
//                drawimage();
//                drawnavi();
            }
            function drawX(id) {
                let cnv = document.getElementById(id);
//                let parent=cnv.parentNode;
//                cnv.width=parent.offsetWidth;
//                cnv.height=parent.offsetHeight;
                let ctx = cnv.getContext("2d");
                ctx.save();
                ctx.fillStyle="lightgray";
                ctx.fillRect(0, 0, cnv.width, cnv.height);
                ctx.restore();
//                ctx.clearRect(0, 0, cnv.width, cnv.height);
//                ctx.lineWidth = 1;
//                ctx.strokeStyle = "red";
//                ctx.strokeRect(0.5, 0.5, cnv.width - 1, cnv.height - 1);
//                ctx.beginPath();
//                ctx.moveTo(0, 0);
//                ctx.lineTo(cnv.width, cnv.height);
//                ctx.moveTo(0, cnv.height);
//                ctx.lineTo(cnv.width, 0);
//                ctx.stroke();
            }

            let strippos;
            let stripidx;
            async function drawstrip() {
                if (!ready)
                    return;

                if (strippos > fsw - width)
                    strippos = fsw - width;
                if (strippos < 0)
                    strippos = 0;
                let current = images[stripidx];

                let cnv = document.getElementById("filmcnv");
                let ctx = cnv.getContext("2d");
                ctx.clearRect(0, 0, width, fstrip);
                ctx.fillStyle = "black";

                let alpha = document.getElementById("stripalpha").valueAsNumber;
                let so = document.getElementById("stripoutline");
                so.disabled = alpha < 100;
                if (so.disabled)
                    alpha = -alpha;
                else
                    alpha = parseInt(so.value.substring(1), 16);

                for (const image of images)
                    if (image.fsx - strippos >= -image.fsw && image.fsx - strippos <= width) {
                        if (image === current) {
                            ctx.fillStyle = "orange";
                            ctx.fillRect(image.fsx - strippos - 10, 0, image.fsw + 20, 128);
                            ctx.fillStyle = "black";
                        }
                        if (image.anchored) {
                            ctx.fillStyle = "green";
                            ctx.fillRect(image.fsx - strippos - 5, 0, image.fsw + 10, 128);
                            ctx.fillStyle = "black";
                        }
                        const icon=image.icon;
                        if (typeof icon === "object") {
                            ctx.drawImage(image.icon, image.fsx - strippos, image.fsy, image.fsw, image.fsh);
                            if (alpha !== 0 || !so.disabled)
                                drawslice(image.ouv, ctx, image.fsx - strippos, image.fsy, image.fsw, image.fsh, alpha);
                        } else {
                            ctx.fillRect(image.fsx - strippos, image.fsy, image.fsw, image.fsh);
                            drawslice(image.ouv, ctx, image.fsx - strippos, image.fsy, image.fsw, image.fsh, -100);
                            if(icon === "loading")
                                continue;
                            const dzip=image.dzip;
                            if(typeof dzip === "string") {
                                if(dzip === "loading")
                                    continue;
                                image.dzip="loading";
                                netunzip(()=>dpurlget(dzip).then(json=>json.url)).then(dzip=>{
                                    image.dzip=dzip;
                                    drawstrip();
                                    const callback=image.callback;
                                    if(callback){
                                        delete image.callback;
                                        callback();
                                    }
                                });
                                continue;
                            }
                            
                            image.icon="loading";
                            
                            let w = image.width;
                            let h = image.height;
                            let t = image.tilesize;
                            let l = image.maxlevel;
                            while (w > t || h > t) {
                                w = (w + 1) >> 1;
                                h = (h + 1) >> 1;
                                l--;
                            }
                            const img=document.createElement("img");
                            if(!dzip){
                                img.onload = () => {
                                    image.icon = img;
                                    drawstrip();
                                };
                                img.crossOrigin = "anonymous";
                                if(series.bucket)
                                    dpurlget(image.base + l + "/0_0." + image.format).then(json => img.src=json.url);
                                else
                                    img.src=oldisv+image.base+l+"/0_0."+image.format;
                            }else{
                                dzip.get(dzip.entries.get(image.base + l + "/0_0." + image.format))
                                        .then(data=>{
                                            const url=URL.createObjectURL(new Blob([data], {type: "image/"+image.format}));
                                            img.onload=()=>{
                                                URL.revokeObjectURL(url);
                                                image.icon=img;
                                                drawstrip();
                                            };
                                            img.src=url;
                                        });
                            }
                        }
                    }
            }
            function stripscroll(event) {
                event.preventDefault();
                strippos -= event.deltaY;
                drawstrip();
            }
            let strippick = false;
            function stripdown(event) {
                if (!ready)
                    return;
                strippick = {downx: event.offsetX, mx: event.offsetX, t: Date.now()};
            }
            let stripmoving = false;
            function stripmove(event) {
                if (!strippick)
                    return;
                let t = Date.now();
                if (t === strippick.t)
                    return;
                let v = (strippick.mx - event.offsetX) / (t - strippick.t);
                strippick.mx = event.offsetX;
                strippick.t = t;
                if (!stripmoving) {
                    stripmoving = {t};
                    requestAnimationFrame(stripanim);
                }
                stripmoving.v = v;
                drawstrip();
            }
            function stripanim() {
                if (!stripmoving)
                    return;
                let t = Date.now();
                strippos += stripmoving.v * (t - stripmoving.t);
                stripmoving.t = t;
                stripmoving.v *= 0.95;
                if (Math.abs(stripmoving.v) < 0.01)
                    stripmoving = false;
                if (strippos > fsw - width) {
                    strippos = fsw - width;
                    stripmoving = false;
                }
                if (strippos < 0) {
                    strippos = 0;
                    stripmoving = false;
                }
                if (stripmoving)
                    requestAnimationFrame(stripanim);
                drawstrip();
            }
            function stripup(event) {
                if (Math.abs(strippick.downx - event.offsetX) < 2) {
                    stripmoving = false;
                    let x = event.offsetX + strippos;
                    for (let i = 0; i < images.length; i++) {
                        let image = images[i];
                        if (image.fsx <= x && x < image.fsx + image.fsw) {
                            activateslice(i);
                            break;
                        }
                    }
                }
                strippick = false;
            }
//            let strippick=false;
//            function stripdown(event){
//                if(!ready)return;
//                strippick={downx:event.offsetX,base:strippos};
//            }
//            function stripmove(event){
//                if(!strippick)return;
//                strippos=strippick.base+strippick.downx-event.offsetX;
//                drawstrip();
//            }
//            function stripup(event){
//                if(Math.abs(strippick.downx-event.offsetX)<2){
//                    let x=event.offsetX+strippos;
//                    for(let i=0;i<images.length;i++){
//                        let image=images[i];
//                        if(image.fsx<=x && x<image.fsx+image.fsw){
//                            activateslice(i);
//                            break;
//                        }
//                    }
//                }
//                strippick=false;
//            }
            function strippick_remove(event) {
                if (!ready)
                    return;
                let x = event.offsetX + strippos;
                for (let i = 0; i < images.length; i++) {
                    let image = images[i];
                    if (image.fsx <= x && x < image.fsx + image.fsw) {
                        activateslice(i);
                        break;
                    }
                }
            }

            let ouv;
            let active_image;
            let undo_stack;
            let undo_pos;
            function activateslice(idx) {
                series.current = idx;
                stripidx = idx;
                marker = false;
                active_image = images[idx];
                document.getElementById("image").innerText = active_image.filename + "\n" + active_image.width + " x " + active_image.height;
                ouv = active_image.ouv.slice();
                imagenavi();
//                drawimage();
                drawstrip();
//                drawnavi();
//                drawcut();
                init_undo();
            }
            function init_undo() {
                undo_stack = [images[stripidx].anchored ? ouv.slice() : false];
                undo_pos = 0;
                document.getElementById("undo").disabled = document.getElementById("redo").disabled = true;
            }
            function store_undo() {
                active_image.anchored = true;
                active_image.ouv = ouv.slice();
                undo_pos++;
                undo_stack.splice(undo_pos);
                undo_stack.push(ouv.slice());
                document.getElementById("undo").disabled = false;
                document.getElementById("redo").disabled = true;

                delete series.sections[stripidx].markers;
                let idx = stripidx - 1;
                while (idx >= 0 && !images[idx].anchored) {
                    delete series.sections[idx].markers;
                    idx--;
                }
                idx = stripidx + 1;
                while (idx < images.length && !images[idx].anchored) {
                    delete series.sections[idx].markers;
                    idx++;
                }

                propagate();
                drawstrip();
            }
            function apply_xdo() {
                document.getElementById("undo").disabled = undo_pos === 0;
                document.getElementById("redo").disabled = undo_pos === undo_stack.length - 1;
                const item = undo_stack[undo_pos];
                if(item) {
                    active_image.anchored = true;
                    ouv = item.slice();
                    active_image.ouv = item.slice();
                } else {
                    active_image.anchored = false;
                }
                propagate();
                if(!item)
                    ouv = active_image.ouv.slice();

                imagenavi();
                drawstrip();
            }
            function undo() {
                undo_pos--;
                apply_xdo();
            }
            function redo() {
                undo_pos++;
                apply_xdo();
            }
            function ouv_clear() {
                if (!ready)
                    return;
                switch (document.getElementById("mode").selectedIndex) {
                    case 0:
                        ouv = [0, atlas.ydim / 2, atlas.zdim - 1,
                            atlas.xdim, 0, 0,
                            0, 0, -atlas.zdim];
                        break;
                    case 1:
                        ouv = [atlas.xdim / 2, atlas.ydim - 1, atlas.zdim - 1,
                            0, -atlas.ydim, 0,
                            0, 0, -atlas.zdim];
                        break;
                    case 2:
                        ouv = [0, atlas.ydim - 1, atlas.zdim / 2,
                            0, -atlas.ydim, 0,
                            atlas.xdim, 0, 0];
                        break;
                }
                imagenavi();
//                drawimage();
//                drawnavi();
            }

            let mainimg = false;
            let marker = false;
            let slice = false;
            async function drawimage() {
                drawX("maincnv");
                if (!ready)
                    return;
                slice = false;
                let idx = stripidx;
                let {width, height, tilesize, overlap, format, base, dzip, maxlevel, fullcanvas/*,ouv*/} = images[idx];
                if(dzip === "loading") {
                    images[idx].callback = drawimage;
                    return;
                }
                let x = 0, y = 0;
                let w = mainw, h = mainh;
                if (w / h < width / height) {
                    h = Math.floor(w * height / width);
                    y = (mainh - h) / 2;
                } else {
                    w = Math.floor(h * width / height);
                    x = (mainw - w) / 2;
                }
                mainimg = {x, y, w, h};
                while (width > w * 2 && height > h * 2) {
                    maxlevel--;
                    width = (width + 1) >> 1;
                    height = (height + 1) >> 1;
                }
                if (!fullcanvas || fullcanvas.width < w || fullcanvas.height < h) {
                    fullcanvas = document.createElement("canvas");
                    let ctx = fullcanvas.getContext("2d");
                    fullcanvas.width = width;
                    fullcanvas.height = height;
                    let xtiles = Math.ceil(width / tilesize);
                    let ytiles = Math.ceil(height / tilesize);
                    let loads = [];
                    let wcopy = mainw;
                    let hcopy = mainh;
                    //let xx=x,yy=y;
                    for (let x = 0; x < xtiles; x++)
                        for (let y = 0; y < ytiles; y++)
                            loads.push(dzip?dzip.get(dzip.entries.get(`${base + maxlevel}/${x}_${y}.${format}`))
                                    .then(data => new Promise((resolve, reject) => {
                                        const url=URL.createObjectURL(new Blob([data], {type: "image/"+image.format}));
                                        let tile = document.createElement("img");
                                        tile.onload = () => {
                                            URL.revokeObjectURL(url);
                                            ctx.drawImage(tile, x * tilesize - (x === 0 ? 0 : overlap), y * tilesize - (y === 0 ? 0 : overlap));
                                            resolve();
                                        };
                                        tile.src = url;
                                    }))
                                :series.bucket?dpurlget(`${base + maxlevel}/${x}_${y}.${format}`)
                                    .then(json => new Promise((resolve, reject) => {
                                            let tile = document.createElement("img");
                                            tile.onerror = reject;
                                            tile.onload = () => {
                                                ctx.drawImage(tile, x * tilesize - (x === 0 ? 0 : overlap), y * tilesize - (y === 0 ? 0 : overlap));
                                                //if(wcopy===mainw && hcopy===mainh && idx===stripidx)
                                                //    document.getElementById("maincnv").getContext("2d").drawImage(fullcanvas,xx,yy,w,h);
                                                resolve();
                                            };
                                            tile.crossOrigin = "anonymous";
                                            tile.src = json.url;
                                        }))
                                :new Promise((resolve,reject)=>{
                                    let tile = document.createElement("img");
                                    tile.onerror = reject;
                                    tile.onload = () => {
                                        ctx.drawImage(tile, x * tilesize - (x === 0 ? 0 : overlap), y * tilesize - (y === 0 ? 0 : overlap));
                                        resolve();
                                    };
                                    tile.crossOrigin = "anonymous";
                                    tile.src = oldisv+base+maxlevel+`/${x}_${y}.${format}`;
                                }));
//                        loads.push(new Promise((resolve,reject)=>{
//                            let tile=document.createElement("img");
//                            tile.onerror=reject;
//                            tile.onload=()=>{
//                                ctx.drawImage(tile,x*tilesize-(x===0?0:overlap),y*tilesize-(y===0?0:overlap));
//                                //if(wcopy===mainw && hcopy===mainh && idx===stripidx)
//                                //    document.getElementById("maincnv").getContext("2d").drawImage(fullcanvas,xx,yy,w,h);
//                                resolve();
//                            };
//                            tile.crossOrigin="anonymous";
//                            tile.src=base+maxlevel+"/"+x+"_"+y+"."+format;
//                        }));
                    await Promise.all(loads);
                    if (wcopy !== mainw || hcopy !== mainh)
                        return;
                    images[idx].fullcanvas = fullcanvas;
                    if (idx !== stripidx)
                        return;
                }
                ctx = document.getElementById("maincnv").getContext("2d");
                ctx.clearRect(0, 0, mainw, mainh);
                ctx.drawImage(fullcanvas, x, y, w, h);
                let alpha = document.getElementById("mainalpha").valueAsNumber;
                if (alpha > 0) { // todo: rate limit
                    let mo = document.getElementById("mainoutline");
                    mo.disabled = alpha < 100;
                    if (mo.disabled)
                        alpha = -alpha;
                    else
                        alpha = parseInt(mo.value.substring(1), 16);
                    slice = {...drawslice(ouv, ctx, x, y, w, h, alpha), x, y, w, h};
                    drawpop();
                    if (marker) {
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        switch (marker.type) {
                            case "cross":
                                ctx.moveTo(x + w * marker.x - 10, y + h * marker.y);
                                ctx.lineTo(x + w * marker.x + 10, y + h * marker.y);
                                ctx.moveTo(x + w * marker.x, y + h * marker.y - 10);
                                ctx.lineTo(x + w * marker.x, y + h * marker.y + 10);
                                break;
                            case "vscale":
                                ctx.moveTo(0, y + h * marker.y);
                                ctx.lineTo(mainw, y + h * marker.y);
                                //                            ctx.moveTo(0,mainy);
                                //                            ctx.lineTo(mainw,mainy);
                                break;
                            case "hscale":
                                ctx.moveTo(x + w * marker.x, 0);
                                ctx.lineTo(x + w * marker.x, mainh);
//                                ctx.moveTo(mainx,0);
//                                ctx.lineTo(mainx,mainh);
                                break;
                            case "rotate":
                                ctx.moveTo(x + w * marker.x - 5, y + h * marker.y);
                                ctx.lineTo(x + w * marker.x + 5, y + h * marker.y);
                                ctx.moveTo(x + w * marker.x, y + h * marker.y - 5);
                                ctx.lineTo(x + w * marker.x, y + h * marker.y + 5);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.arc(x + w * marker.x, y + h * marker.y, 10, 3 * Math.PI / 4, Math.PI / 4);
                                break;
                        }
                        ctx.stroke();
                    }
                }
            }

            let drawpopscaping = false;
            let drawpopdata = 0;
            function drawpop() {
                if (!slice)
                    return;
                const x = Math.round((mainx - slice.x) * slice.width / slice.w);
                const y = Math.round((mainy - slice.y) * slice.height / slice.h);
                const out = x < 0 || y < 0 || x >= slice.width || y >= slice.height;
                const d = out ? 0 : slice.data[x + y * slice.width];
                let newscaping = drawpopscaping;
                if (mainy < mainh / 3)
                    newscaping = false;
                if (mainy > mainh * 2 / 3)
                    newscaping = true;
                if (d === 0) {
                    drawpopscaping = newscaping;
                    if (drawpopdata !== 0) {
                        drawpopdata = 0;
                        drawimage();
                    }
                } else {
                    if (newscaping !== drawpopscaping) {
                        drawpopscaping = newscaping;
                        drawpopdata = 0;
                        drawimage();
                    } else if (drawpopdata !== d) {
                        drawpopdata = d;
                        const pop = atlas.labels[d];
                        const ctx = document.getElementById("maincnv").getContext("2d");
                        ctx.fillStyle = "rgb(" + pop.r + "," + pop.g + "," + pop.b + ")";
                        if (drawpopscaping)
                            ctx.fillRect(0, 0, mainw, 60);
                        else
                            ctx.fillRect(0, mainh - 60, mainw, 60);
                        let fontsize = 40;
                        do {
                            ctx.font = `${fontsize}px sans-serif`;
                            fontsize--;
                        } while (ctx.measureText(pop.name).width > mainw - 20 && fontsize > 1);
                        ctx.fillStyle = "#000000";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        if (drawpopscaping)
                            ctx.fillText(pop.name, mainw / 2, 30);
                        else
                            ctx.fillText(pop.name, mainw / 2, mainh - 30);
                    }
                }
            }

            let navw = 0;
            let nfact;
            let zfact;
            let xfact;
            let midpoint;
            function drawnavi() {
                if (!ready)
                    return;
                let {xdim, ydim, zdim} = atlas;
                let cnv = document.getElementById("navicnv");
                let ctx = cnv.getContext("2d");
                ctx.clearRect(0, 0, cnv.width, cnv.height);
//                let nfact=(mainh-10-10)/(atlas.zdim+atlas.zdim+atlas.xdim);
                let points = [[0, 0], [1, 0], [1, 1], [0, 1], [0.5, 0.5]].map(uv =>
                    [0, 1, 2].map(idx => ouv[idx] + uv[0] * ouv[idx + 3] + uv[1] * ouv[idx + 6]));
//                let x=ouv[0]+(ouv[3]+ouv[6])/2;
//                let y=ouv[1]+(ouv[4]+ouv[7])/2;
//                let z=ouv[2]+(ouv[5]+ouv[8])/2;
                xfact = xdim * nfact;
                zfact = zdim * nfact;
                let navi = document.getElementById("navi");
                let g1 = document.getElementById("group1");
                g1.style.left = navi.offsetLeft + "px";
                g1.style.top = navi.offsetTop + "px";
                let g2 = document.getElementById("group2");
                g2.style.left = navi.offsetLeft + "px";
                g2.style.top = navi.offsetTop + zfact + 10 + "px";
                let g3 = document.getElementById("group3");
                g3.style.left = navi.offsetLeft + navw - xfact + "px";
                g3.style.top = navi.offsetTop + zfact + xfact + 10 + 10 + "px";
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, navw, zfact);
                ctx.fillRect(0, zfact + 10, navw, xfact);
                ctx.fillRect(navw - xfact, zfact + xfact + 10 + 10, xfact, zfact);
                drawslice([points[4][0], ydim - 1, zdim - 1,
                    0, -ydim, 0,
                    0, 0, -zdim], ctx, 0, 0, navw, zfact, -100);
                drawslice([xdim - 1, ydim - 1, points[4][2],
                    0, -ydim, 0,
                    -xdim, 0, 0], ctx, 0, zfact + 10, navw, xfact, -100);
                drawslice([0, points[4][1], zdim - 1,
                    xdim, 0, 0,
                    0, 0, -zdim], ctx, navw - xfact, zfact + xfact + 10 + 10, xfact, zfact, -100);
                let npoints = points.map(p => [p[0] * nfact, navw - p[1] * nfact, zfact - p[2] * nfact]);
                midpoint = npoints[4];

                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(npoints[0][1], npoints[0][2]);
                ctx.lineTo(npoints[1][1], npoints[1][2]);
                ctx.lineTo(npoints[2][1], npoints[2][2]);
                ctx.lineTo(npoints[3][1], npoints[3][2]);
                ctx.closePath();
                ctx.fillStyle = "blue";
                ctx.globalAlpha = 0.2;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = "yellow";
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(npoints[4][1], npoints[4][2], 3, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = "yellow";
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(npoints[0][1], xfact - npoints[0][0] + zfact + 10);
                ctx.lineTo(npoints[1][1], xfact - npoints[1][0] + zfact + 10);
                ctx.lineTo(npoints[2][1], xfact - npoints[2][0] + zfact + 10);
                ctx.lineTo(npoints[3][1], xfact - npoints[3][0] + zfact + 10);
                ctx.closePath();
                ctx.fillStyle = "blue";
                ctx.globalAlpha = 0.2;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = "yellow";
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(npoints[4][1], xfact - npoints[4][0] + zfact + 10, 3, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = "yellow";
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(npoints[0][0] + navw - xfact, npoints[0][2] + zfact + 10 + xfact + 10);
                ctx.lineTo(npoints[1][0] + navw - xfact, npoints[1][2] + zfact + 10 + xfact + 10);
                ctx.lineTo(npoints[2][0] + navw - xfact, npoints[2][2] + zfact + 10 + xfact + 10);
                ctx.lineTo(npoints[3][0] + navw - xfact, npoints[3][2] + zfact + 10 + xfact + 10);
                ctx.closePath();
                ctx.fillStyle = "blue";
                ctx.globalAlpha = 0.2;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = "yellow";
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(npoints[4][0] + navw - xfact, npoints[4][2] + zfact + 10 + xfact + 10, 3, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = "yellow";
                ctx.fill();
            }

            function drawcut() {

            }

            let drag_ouv;
            let drag = false;
            function mup(event) {
                if (drag) {
                    drag = false;
                    if(drag_ouv.some((e,i) => e !== ouv[i]))
                        store_undo();
                    if (marker) {
                        marker.type = "cross";
                        drawimage();
                    }
                }
            }
            function hresize(event) {
                drag = {type: "hresize", x: event.target.offsetWidth - event.offsetX};
            }
            function vresize(event) {
                drag = {type: "vresize", y: event.target.offsetHeight - event.offsetY};
            }
            function range(v, c, r) {
                return v >= c - r && v <= c + r;
            }
            function ndrag(event) {
//                ctx.arc(npoints[4][1],npoints[4][2],3,0,Math.PI*2);
//                ctx.arc(npoints[4][1],npoints[4][0]+zfact+10,3,0,Math.PI*2);
//                ctx.arc(npoints[4][0]+navw-xfact,npoints[4][2]+zfact+10+xfact+10,3,0,Math.PI*2);
                drag = {x: event.offsetX, y: event.offsetY};
                drag_ouv = ouv.slice();
                if (range(event.offsetX, midpoint[1], 5) && range(event.offsetY, midpoint[2], 5)) {
                    drag.type = "sdrag";
                } else if (range(event.offsetX, midpoint[1], 5) && range(event.offsetY, xfact - midpoint[0] + zfact + 10, 5)) {
                    drag.type = "hdrag";
                } else if (range(event.offsetX, midpoint[0] + navw - xfact, 5) && range(event.offsetY, midpoint[2] + zfact + 10 + xfact + 10, 5)) {
                    drag.type = "cdrag";
                } else if (event.offsetY < zfact) {
                    drag.type = "srot";
                } else if (event.offsetY > zfact + 10 + xfact + 10) {
                    drag.type = "crot";
                } else
                    drag.type = "hrot";
            }

            let mainx = -1, mainy = -1;
            function mainmove(event) {
                mainx = event.offsetX;
                mainy = event.offsetY;
                drawpop();
            }
            function maindrag(event) {
                drag = {type: "mdrag", x: event.offsetX, y: event.offsetY};
                drag_ouv = ouv.slice();
            }
            function maindown(event) {
                event.preventDefault();
                if (!marker || event.code === "Space")
                    marker = {type: "cross",
                        x: (mainx - mainimg.x) / mainimg.w,
                        y: (mainy - mainimg.y) / mainimg.h};
                if (event.code === "Escape")
                    marker = false;
                if (event.code === "Space")
                    marker.type = "cross";
                if (event.code === "ArrowUp" || event.code === "ArrowDown")
                    marker.type = "vscale";
                if (event.code === "ArrowLeft" || event.code === "ArrowRight")
                    marker.type = "hscale";
                if (event.code === "PageUp" || event.code === "PageDown")
                    marker.type = "rotate";
                drawimage();
            }
            function mmove(event) {
                if (!drag)
                    return;
                let angles;
                switch (drag.type) {
                    case "hresize":
                        ctrlw = event.clientX - drag.x;
                        resize();
                        return;
                    case "vresize":
                        fstrip = Math.max(0, window.innerHeight - event.clientY - drag.y);
                        resize();
                        return;
                    case "sdrag":
                        ouv[1] += (drag.x - event.offsetX) / nfact;
                        ouv[2] += (drag.y - event.offsetY) / nfact;
                        break;
                    case "hdrag":
                        ouv[1] += (drag.x - event.offsetX) / nfact;
                        ouv[0] += (drag.y - event.offsetY) / nfact;
                        break;
                    case "cdrag":
                        ouv[0] -= (drag.x - event.offsetX) / nfact;
                        ouv[2] += (drag.y - event.offsetY) / nfact;
                        break;
                    case "srot":
                        angles = sincos(midpoint[1], midpoint[2], drag.x, drag.y, event.offsetX, event.offsetY);
                        decomp(ouv);
                        rot(ouv, 4, 5, angles);
                        rot(ouv, 7, 8, angles);
                        recomp(ouv);
                        break;
                    case "hrot":
                        angles = sincos(midpoint[1], xfact - midpoint[0] + zfact + 10, drag.x, drag.y, event.offsetX, event.offsetY);
                        decomp(ouv);
                        rot(ouv, 4, 3, angles);
                        rot(ouv, 7, 6, angles);
                        recomp(ouv);
                        break;
                    case "crot":
                        angles = sincos(midpoint[0] + navw - xfact, midpoint[2] + zfact + 10 + xfact + 10, event.offsetX, event.offsetY, drag.x, drag.y);
                        decomp(ouv);
                        rot(ouv, 3, 5, angles);
                        rot(ouv, 6, 8, angles);
                        recomp(ouv);
                        break;
                    case "mdrag":
                        if (!marker || marker.type === "cross") {
                            for (let i = 0; i < 3; i++) {
                                ouv[i] += ouv[i + 3] * (drag.x - event.offsetX) / mainimg.w;
                                ouv[i] += ouv[i + 6] * (drag.y - event.offsetY) / mainimg.h;
                            }
                        } else {
                            switch (marker.type) {
                                case "vscale":
                                    let vfactor = ((drag.y - mainimg.y) - mainimg.h * marker.y) / ((event.offsetY - mainimg.y) - mainimg.h * marker.y);
                                    for (let i = 0; i < 3; i++) {
                                        ouv[i] += ouv[i + 6] * marker.y;
                                        ouv[i + 6] *= vfactor;
                                        ouv[i] -= ouv[i + 6] * marker.y;
                                    }
                                    break;
                                case "hscale":
                                    let hfactor = ((drag.x - mainimg.x) - mainimg.w * marker.x) / ((event.offsetX - mainimg.x) - mainimg.w * marker.x);
                                    for (let i = 0; i < 3; i++) {
                                        ouv[i] += ouv[i + 3] * marker.x;
                                        ouv[i + 3] *= hfactor;
                                        ouv[i] -= ouv[i + 3] * marker.x;
                                    }
                                    break;
                                case "rotate":
                                    let angles = sincos(mainimg.x + mainimg.w * marker.x,
                                            mainimg.y + mainimg.h * marker.y,
                                            drag.x, drag.y, event.offsetX, event.offsetY);
                                    for (let i = 0; i < 3; i++) {
                                        ouv[i] += ouv[i + 3] * marker.x + ouv[i + 6] * marker.y;
//                                        ouv[i+3]/=mainimg.w;
//                                        ouv[i+6]/=mainimg.h;
//                                        ouv[i]-=(ouv[i+3]+ouv[i+6])/2;
                                    }
//                                    decomp(ouv);
                                    let u = ouv.slice(3, 6);
                                    let v = ouv.slice(6);
                                    for (let i = 0; i < 3; i++) {
                                        ouv[i + 3] = u[i] * angles[1] - v[i] * angles[0];
                                        ouv[i + 6] = u[i] * angles[0] + v[i] * angles[1];
                                    }
//                                    u=mainimg.w/ouv[9];
//                                    v=mainimg.h/ouv[10];
////                                    u=ouv[9];
////                                    v=ouv[10];
//                                    ouv[9]=mainimg.w/(u*angles[1]-v*angles[0]);
//                                    ouv[10]=mainimg.h/(u*angles[0]+v*angles[1]);
//                                    recomp(ouv);
                                    for (let i = 0; i < 3; i++) {
//                                        ouv[i]+=(ouv[i+3]+ouv[i+6])/2;
//                                        ouv[i+3]*=mainimg.w;
//                                        ouv[i+6]*=mainimg.h;
                                        ouv[i] -= ouv[i + 3] * marker.x + ouv[i + 6] * marker.y;
                                    }

                            }
                        }
                        break;
                }
                imagenavi();
//                drawnavi();
//                drawimage();
                drag.x = event.offsetX;
                drag.y = event.offsetY;
            }
            function propagate() {
                let anchoring = false;
                for (let image of images)
                    if (image.anchored === true) {
                        if (anchoring === false)
                            anchoring = image;
                        else
                            anchoring = true;
                    }
                if (anchoring === false) {
                    let keyslice = images[Math.min(images.length - 1, (images.length >> 1) + 1)];
                    let ouv = [0, atlas.ydim / 2, atlas.zdim - 1,
                        atlas.xdim, 0, 0,
                        0, 0, -atlas.zdim
                    ];
                    decomp(ouv, keyslice.width, keyslice.height);
                    for (let image of images)
                        recomp(image.ouv = ouv.slice(), image.width, image.height);
                } else if (anchoring !== true) {
                    let ouv = anchoring.ouv;
                    decomp(ouv, anchoring.width, anchoring.height);
                    for (let image of images)
                        recomp(image.ouv = ouv.slice(), image.width, image.height);
                } else {
                    let linregs = [];
                    for (let i = 0; i < 11; i++)
                        linregs.push(new LinReg());
                    for (let image of images)
                        if (image.anchored) {
                            let ouv = image.ouv;
                            decomp(ouv, image.width, image.height);
                            for (let i = 0; i < ouv.length; i++)
                                linregs[i].add(image.snr, ouv[i]);
                        }
                    let clearfirst = false;
                    let clearlast = false;
                    if (!images[0].anchored) {
                        let image = images[0];
                        let w = [];
                        for (let linreg of linregs)
                            w.push(linreg.get(image.snr));
                        orthonormalize(w);
                        image.ouv = w;
                        image.anchored = clearfirst = true;
                    }
                    if (!images[images.length - 1].anchored) {
                        let image = images[images.length - 1];
                        let w = [];
                        for (let linreg of linregs)
                            w.push(linreg.get(image.snr));
                        orthonormalize(w);
                        image.ouv = w;
                        image.anchored = clearlast = true;
                    }
                    let start = 0;
                    while (start < images.length - 1) {
                        let end = start + 1;
                        while (!images[end].anchored)
                            end++;
                        if (end > start + 1) {
                            let si = images[start];
                            let ssnr = si.snr;
                            let souv = si.ouv;
                            let ei = images[end];
                            let esnr = ei.snr;
                            let eouv = ei.ouv;
                            let linints = [];
                            for (let i = 0; i < 11; i++)
                                linints.push(new LinInt(ssnr, souv[i], esnr, eouv[i]));
                            for (let j = start + 1; j < end; j++) {
                                let image = images[j];
                                let snr = image.snr;
                                let w = [];
                                for (let linint of linints)
                                    w.push(linint.get(snr));
                                orthonormalize(w);
                                image.ouv = w;
                            }
                        }
                        start = end;
                    }
                    if (clearfirst)
                        images[0].anchored = false;
                    if (clearlast)
                        images[images.length - 1].anchored = false;
                    for (let image of images)
                        recomp(image.ouv, image.width, image.height);
                }

            }
            async function save() {
                if (filename.endsWith(".waln"))
                    dosave();
                else
                    saveas();
            }
            async function saveas() {
                const choice = await dppick({
                    bucket,
                    token,
                    title: "Save as...",
                    path: filename.substring(0, filename.lastIndexOf("/") + 1),
                    extensions: [".waln"],
                    create: ".waln",
                    createdefault: filename.slice(filename.lastIndexOf("/") + 1, -5) + ".waln",
                    createbutton: "Save"
                });
                if (choice.cancel)
                    return;
                filename = choice.create || choice.pick;
                dosave();
            }
            async function dosave() {
                for (let i = 0; i < images.length; i++) {
                    let image = images[i];
                    if (image.anchored)
                        series.sections[i].ouv = image.ouv;
                    else
                        delete series.sections[i].ouv;
                }
                let upload = await fetch(
                        `https://data-proxy.ebrains.eu/api/v1/buckets/${bucket}/${filename}`, {
                            method: "PUT",
                            headers: {
                                accept: "application/json",
                                authorization: `Bearer ${token}`
                            }
                        }
                ).then(response => response.json());
                if (!upload.hasOwnProperty("url")) {
                    alert("Can't save: " + JSON.stringify(upload));
                    return;
                }
                await fetch(upload.url, {
                    method: "PUT",
                    headers: {
                        'Content-Type': 'application/x.webalign'
                    },
                    body: JSON.stringify(series)
                });
            }
            function popup(pop) {
                document.getElementById("cover").hidden = false;
                document.getElementById("popup").hidden = false;
                document.getElementById("popcont").innerHTML = pop;
            }
            function cover() {
                document.getElementById("cover").hidden = true;
                document.getElementById("popup").hidden = true;
            }
            async function exprt() {
                let date = new Date();
                let te = new TextEncoder();

                let ziplist = [];

                let descriptor = {
                    target: series.atlas,
                    slices: images.map(image => ({filename: image.filename, width: image.width, height: image.height, anchoring: image.ouv}))
                };
                ziplist.push({
                    name: "anchorings.json",
                    date,
                    data: te.encode(JSON.stringify(descriptor, null, 1))
                });

                for (let i = 0; i < images.length; i++) {
                    let image = images[i];
                    popup(`${i + 1}/${images.length} ${image.filename}`);

                    let slice = dataslice(image.ouv);
//                    let rebuf=new ArrayBuffer(slice.data.byteLength+9);
//                    let dv=new DataView(rebuf);
//                    dv.setUint8(0,2);
//                    dv.setUint32(1,slice.width,false);
//                    dv.setUint32(5,slice.height,false);
//                    for(let pos=0;pos<slice.data.length;pos++){
//                        dv.setUint16(9+pos*2,atlas.hackmap[atlas.remap[slice.data[pos]]],false);
//                    }
//                    ziplist.push({
//                        name:image.flat,
//                        date,
//                        data:new Uint8Array(rebuf)
//                    });

                    slice.aid = series.atlas;
                    ziplist.push({
                        name: image.flat.substring(0, image.flat.length - 5) + ".seg",
                        date,
                        data: segrle(slice)
                    });

                    let canvas = document.createElement("canvas");
                    canvas.width = slice.width;
                    canvas.height = slice.height;
                    let ctx = canvas.getContext("2d");
                    let idata = ctx.createImageData(slice.width, slice.height);
                    let data = idata.data;
                    for (let pos = 0; pos < slice.data.length; pos++) {
                        let v = slice.data[pos];
                        if (v !== 0) {
                            let l = atlas.labels[v];
                            data[pos * 4] = l.r;
                            data[pos * 4 + 1] = l.g;
                            data[pos * 4 + 2] = l.b;
                            data[pos * 4 + 3] = 255;
                        }
                    }
                    ctx.putImageData(idata, 0, 0);
                    ziplist.push({
                        name: image.flat.substring(0, image.flat.length - 5) + ".png",
                        date,
                        data: new Uint8Array(await new Promise(resolve => canvas.toBlob(blob => resolve(blob.arrayBuffer()))))
                    });
                }

                let zipfile = zipstore(ziplist);

//                let pos = filename.lastIndexOf(".");
//                let zipname = filename.substr(0, pos) + ".zip";

                const choice = await dppick({
                    bucket,
                    token,
                    title: "Export overlays...",
                    path: filename.substring(0, filename.lastIndexOf("/") + 1),
                    extensions: [".zip"],
                    create: ".zip",
                    createdefault: filename.slice(filename.lastIndexOf("/") + 1, -5) + ".zip",
                    createbutton: "Export"
                });
                if (choice.cancel) {
                    cover();
                    return;
                }
                let zipname = choice.create || choice.pick;

                popup("Uploading overlays");
                let upload = await fetch(
                        `https://data-proxy.ebrains.eu/api/v1/buckets/${bucket}/${zipname}`, {
                            method: "PUT",
                            headers: {
                                accept: "application/json",
                                authorization: `Bearer ${token}`
                            }
                        }
                ).then(response => response.json());
                if (!upload.hasOwnProperty("url")) {
                    alert("Can't save: " + JSON.stringify(upload));
                    return;
                }
                await fetch(upload.url, {
                    method: "PUT",
                    headers: {
                        'Content-Type': 'application/zip'
                    },
                    body: zipfile
                });
                cover();
            }
            function imagenavi() {
                drawimage();
                drawnavi();
                angles();
            }
            function angles() {
                if (!ready)
                    return;
                series.mode = document.getElementById("mode").selectedIndex;
                let rots = rot123uvfrom(ouv, series.mode);
                document.getElementById("rot1").value = deg(rots[0]).toFixed(2);
                document.getElementById("rot2").value = deg(rots[1]).toFixed(2);
                document.getElementById("rot3").value = deg(rots[2]).toFixed(2);
            }
            function rot123uvfrom(ouv, mode) {
                let u = ouv.slice(3, 6);
                let v = ouv.slice(6);
                let ul = normalize(u, 0);
                let vl = normalize(v, 0);
                let n = cross(u, v);
                normalize(n, 0);
                let rot1, rot2, baseu;
                switch (mode) {
                    case 0:
                        rot1 = Math.asin(clamp(n[2]));
                        rot2 = Math.atan2(n[0], n[1]);
                        baseu = [Math.cos(rot2), -Math.sin(rot2), 0];
                        break;
                    case 1:
                        rot1 = -Math.asin(clamp(n[2]));
                        rot2 = -Math.atan2(n[1], n[0]);
                        baseu = [-Math.sin(rot2), -Math.cos(rot2), 0];
                        break;
                    case 2:
                        rot1 = Math.asin(clamp(n[0]));
                        rot2 = -Math.atan2(n[1], n[2]);
                        baseu = [0, -Math.cos(rot2), -Math.sin(rot2)];
                        break;
                }
                let rot3 = Math.acos(clamp(dot(u, baseu))) * Math.sign(dot(cross(u, baseu), n));
                return [rot1, rot2, rot3, ul, vl];
            }
            function docalc() {
                let rot1 = rad(document.getElementById("rot1").valueAsNumber);
                let rot2 = rad(document.getElementById("rot2").valueAsNumber);
                let rot3 = rad(document.getElementById("rot3").valueAsNumber);
                fromrot123uv(ouv, [rot1, rot2, rot3, len3(ouv, 3), len3(ouv, 6)], document.getElementById("mode").selectedIndex);
                imagenavi();
            }
            function fromrot123uv(ouv, rot123uv, mode) {
                let [rot1, rot2, rot3, u, v] = rot123uv;
                let scaladd = (u, s1, v, s2, t, i) => {
                    t[i] = u[0] * s1 + v[0] * s2;
                    t[i + 1] = u[1] * s1 + v[1] * s2;
                    t[i + 2] = u[2] * s1 + v[2] * s2;
                };
                for (let i = 0; i < 3; i++)
                    ouv[i] += (ouv[i + 3] + ouv[i + 6]) / 2;
                let baseu, basev;
                switch (mode) {
                    case 0:
                        baseu = [Math.cos(rot2), -Math.sin(rot2), 0];
                        basev = [Math.sin(rot1) * Math.sin(rot2), Math.sin(rot1) * Math.cos(rot2), -Math.cos(rot1)];
                        break;
                    case 1:
                        baseu = [-Math.sin(rot2), -Math.cos(rot2), 0];
                        basev = [-Math.sin(rot1) * Math.cos(rot2), Math.sin(rot1) * Math.sin(rot2), -Math.cos(rot1)];
                        break;
                    case 2:
                        baseu = [0, -Math.cos(rot2), -Math.sin(rot2)];
                        basev = [Math.cos(rot1), Math.sin(rot1) * Math.sin(rot2), -Math.sin(rot1) * Math.cos(rot2)];
                        break;
                }
                scaladd(baseu, Math.cos(rot3), basev, -Math.sin(rot3), ouv, 3);
                scaladd(baseu, Math.sin(rot3), basev, Math.cos(rot3), ouv, 6);
                for (let i = 0; i < 3; i++) {
                    ouv[i + 3] *= u;
                    ouv[i + 6] *= v;
                    ouv[i] -= (ouv[i + 3] + ouv[i + 6]) / 2;
                }
            }
            function unify() {
                let mode = document.getElementById("mode").selectedIndex;
                let [rot1, rot2] = rot123uvfrom(ouv, mode);
                for (let image of images) {
                    let rot123uv = rot123uvfrom(image.ouv, mode);
                    rot123uv[0] = rot1;
                    rot123uv[1] = rot2;
                    fromrot123uv(image.ouv, rot123uv, mode);
                }
                drawstrip();
            }
            function clickstep(coord, dir) {
                ouv[coord] += document.getElementById("panstep").valueAsNumber * dir;
                imagenavi();
            }
            function clickrot(c1, c2, dir) {
                const angle = document.getElementById("rotstep").valueAsNumber * dir * Math.PI / 180;
                const sincos = [Math.sin(angle), Math.cos(angle)];
                decomp(ouv);
                rot(ouv, 3 + c1, 3 + c2, sincos);
                rot(ouv, 6 + c1, 6 + c2, sincos);
                recomp(ouv);
                imagenavi();
            }
            function mainstep(x, y) {
                let step = document.getElementById("panstep").valueAsNumber;
                decomp(ouv);
                for (let i = 0; i < 3; i++) {
                    ouv[i] += ouv[i + 3] * step * x;
                    ouv[i] += ouv[i + 6] * step * y;
                }
                recomp(ouv);
                imagenavi();
            }
            function mainrot(dir) {
                const angle = document.getElementById("rotstep").valueAsNumber * dir * Math.PI / 180;
                const sincos = [Math.sin(angle), Math.cos(angle)];
                decomp(ouv);
                let u = ouv.slice(3, 6);
                let v = ouv.slice(6);
                for (let i = 0; i < 3; i++) {
                    ouv[i + 3] = u[i] * sincos[1] - v[i] * sincos[0];
                    ouv[i + 6] = u[i] * sincos[0] + v[i] * sincos[1];
                }
                recomp(ouv);
                imagenavi();
            }
            function toggleHelp() {
                const help = document.getElementById("help");
                help.style.display = help.style.display !== "block" ? "block" : "none";
            }
        </script>
    </head>
    <body onload="startup()" onmouseup="mup(event)" onmousemove="mmove(event)">
        <div id="controls">
            <span id="image"><br></span><button style="float: right" onclick="toggleHelp()">?</button><br>
            <span id="atlas"></span>
            <hr>
            Bucket:
            <button onclick="save()">Save</button><button onclick="saveas()">Save as...</button><button onclick="exprt()">Export overlays</button>
            <div class="ctrlrow">
                <select id="modality" oninput="drawimage();drawstrip();drawnavi();" disabled>
                    <option>Segmentation</option>
                    <option>Template</option>
                </select>
                &#x2194;&#x2195;<input id="panstep" type="number" min="0" max="20" step="0.1" value="1">
                <!--1f504-->&#x21BA;<input id="rotstep" type="number" min="0" max="20" step="0.1" value="1">
            </div>
            <div class="ctrlrow">
                Overlay:
                <input id="mainalpha" type="range" min="0" max="100" step="1" value="100" oninput="drawimage()">
                <input id="mainoutline" type="color" value="#0000FF" oninput="drawimage()">
            </div>
            <div class="ctrlrow">
                Filmstrip:
                <input id="stripalpha" type="range" min="0" max="100" step="1" value="100" oninput="drawstrip()">
                <input id="stripoutline" type="color" value="#0000FF" oninput="drawstrip()">
            </div>
            <hr>
            <div class="ctrlrow" id="gray" disabled="true">
                Brighten:
                <input id="contrast" type="range" min="0" max="255" step="1" value="255" oninput="imagenavi();drawstrip();">
            </div>
            <hr>
            <!--<button onclick="store()">Store</button><button onclick="restore()">Restore</button><button onclick="ouv_clear()">Clear</button>-->
            <button id="undo" onclick="undo()">Undo</button><button id="redo" onclick="redo()">Redo</button><button onclick="ouv_clear()">Clear</button>
            <hr>
            <select id="mode" oninput="angles()">
                <option>Coronal</option>
                <option>Sagittal</option>
                <option>Horizontal</option>
            </select> angles:<br>
            <input type="number" id="rot1" min="-90" max="90" step="0.1" oninput="docalc()">
            <input type="number" id="rot2" min="-180" max="180" step="0.1" oninput="docalc()">
            <input type="number" id="rot3" min="-180" max="180" step="0.1" oninput="docalc()"><br>
            <button onclick="unify()">Apply to all</button>
            <div id="log" hidden></div>
        </div>
        <div id="hsiz" class="hsep" onmousedown="hresize(event)"></div>
        <div id="main">
            <div class="stepgroup">
                <button onclick="mainstep(1, 0)">&#x25c0;</button>
                <button onclick="mainstep(-1, 0)">&#x25b6;</button>
                <button onclick="mainstep(0, 1)">&#x25b2;</button>
                <button onclick="mainstep(0, -1)">&#x25bc;</button>
                <button onclick="mainrot(-1)">&#x21b6;</button>
                <button onclick="mainrot(1)">&#x21b7;</button>
            </div>
            <canvas id="maincnv" tabindex="1"
                    onmousedown="maindrag(event)"
                    onmousemove="mainmove(event)"
                    onkeydown="maindown(event)"
                    onmouseover="/*event.target.focus()*/"
                    onmouseout="/*event.target.blur();*/mainmove(event)"></canvas>
        </div>
        <div id="hsep" class="hsep"></div>
        <div id="navi">
            <canvas id="navicnv" onmousedown="ndrag(event)"></canvas>
        </div>
        <div id="vsiz" onmousedown="vresize(event)"></div>
        <div id="filmstrip">
            <!--<canvas id="filmcnv" onclick="strippick(event)" onwheel="stripscroll(event)"></canvas>-->
            <canvas id="filmcnv" onmousedown="stripdown(event)" onmousemove="stripmove(event)" onmouseup="stripup(event)" onwheel="stripscroll(event)"></canvas>
        </div>
        <div id="cover">        </div>
        <div id="popup">
            <div id="popcont"></div>
        </div>
        <div id="group1" class="stepgroup">
            <button onclick="clickstep(1, 1)">&#x25c0;</button>
            <button onclick="clickstep(1, -1)">&#x25b6;</button>
            <button onclick="clickstep(2, 1)">&#x25b2;</button>
            <button onclick="clickstep(2, -1)">&#x25bc;</button>
            <button onclick="clickrot(1, 2, -1)">&#x21b6;</button>
            <button onclick="clickrot(1, 2, 1)">&#x21b7;</button>
        </div>
        <div id="group2" class="stepgroup">
            <button onclick="clickstep(1, 1)">&#x25c0;</button>
            <button onclick="clickstep(1, -1)">&#x25b6;</button>
            <button onclick="clickstep(0, 1)">&#x25b2;</button>
            <button onclick="clickstep(0, -1)">&#x25bc;</button>
            <button onclick="clickrot(1, 0, -1)">&#x21b6;</button>
            <button onclick="clickrot(1, 0, 1)">&#x21b7;</button>
        </div>
        <div id="group3" class="stepgroup">
            <button onclick="clickstep(0, -1)">&#x25c0;</button>
            <button onclick="clickstep(0, 1)">&#x25b6;</button>
            <button onclick="clickstep(2, 1)">&#x25b2;</button>
            <button onclick="clickstep(2, -1)">&#x25bc;</button>
            <button onclick="clickrot(0, 2, 1)">&#x21b6;</button>
            <button onclick="clickrot(0, 2, -1)">&#x21b7;</button>
        </div>
        <div id="help">
            <div style="text-align: center; width: 100%;">WebAlign v0.7</div><br>
            Navigation views:
            <ul>
                <li>Move overlay via dragging the yellow dot with the mouse</li>
                <li>Rotate overlay via dragging anywhere else than the yellow dot</li>
                <li>Use the buttons for stepwise movement and rotation</li>
                <li>Movement and rotation steps are set in the left panel (&#x2194;&#x2195; and &#x21BA;)</li>
            </ul>
            Main view:
            <ul>
                <li>Pan overlay via mouse drag</li>
                <li>Use the buttons for stepwise panning and rotation (around section midpoint)</li>
                <li>Panning and rotation steps are set in the left panel (&#x2194;&#x2195; and &#x21BA;)</li>
                <li>Place fixed point for resizing and rotation by pressing <kbd>Space</kbd></li>
                <li>Select horizontal resize mode using <kbd>Left</kbd> or <kbd>Right</kbd> arrow keys</li>
                <li>Select vertical resize mode using <kbd>Up</kbd> or <kbd>Down</kbd> arrow keys</li>
                <li>Select rotation mode using <kbd>PageUp</kbd> or <kbd>PageDown</kbd> keys</li>
                <li>Move the mouse pointer away from the fixed point, and apply resizing/rotation via mouse drag</li>
                <li>After releasing the mouse button, operating mode will automatically reset to panning</li>
                <li>Press <kbd>Esc</kbd> to make the fixed point marker disappear</li>
            </ul>
            <a href="https://quint-webtools.readthedocs.io/en/latest/WebAlign.html" target="_blank">Documentation</a><br>
        </div>
    </body>
</html>
